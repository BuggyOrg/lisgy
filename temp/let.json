{
  "code": ";(defcop add [a b] [c])\r\n;(defco test [a] [:o (let [b 2] (add a b))])\r\n;(let [a 1 b 2] (add a b))\r\n\r\n;(defcop choose [var check] [outTrue outFalse])\r\n;(defcop join [pathOne pathTwo] [outPath])\r\n;(defco inc [i] [:inc (math/add 1 i)])\r\n(def = logic/equal)\r\n(def add math/add)\r\n(def mul math/multiply)\r\n(def choose logic/demux)\r\n(def join control/join)\r\n\r\n(defco test [s1 s2] [:sum (add s1 (port :sum (add s2 3)))\r\n                     :out2 (mul s2 2)])\r\n(test 10 20)\r\n\r\n(add 3 (add 10 (mul 1 2)))\r\n\r\n; idealer syntax mit if\r\n; (defco faculty [n]\r\n;        [:fac (if (= n 1)\r\n;                  n\r\n;                  (mul (faculty (add n -1)) n))])\r\n\r\n; wobei if im grunde wie folg definiert ist\r\n; (defco if [check var true false]\r\n;           [:out (let [d (demux var check)\r\n;                       trueP (port :outTrue d)\r\n;                       falseP (port :outFalse d)]\r\n;                       (join true false))])\r\n\r\n; und man faculty auch so schreiben könnte\r\n; (defco faculty [n]\r\n;        [:fac (let [d (choose n (= n 1))\r\n;                    trueV (port :outTrue d)\r\n;                    falseV (port :outFalse d)]\r\n;                (join\r\n;                  trueV\r\n;                  (mul (faculty (add falseV -1)) falseV)))])\r\n\r\n; und let dann wiederum aufgelöst wird zu\r\n; (defco faculty [n]\r\n;        [:fac (join\r\n;                (port :outTrue (choose n (= n 1)))\r\n;                (mul (faculty (add\r\n;                                (port :outFalse (choose n (= n 1)))\r\n;                                -1))\r\n;                     (port :outFalse (choose n (= n 1)))))])\r\n\r\n\r\n\r\n\r\n;(defco math/faculty (n) (:fac (\r\n; (if (= n 1)\r\n;   n\r\n;   (* (math/faculty (- n 1)) n)\r\n;))))\r\n\r\n\r\n; (defco faculty [n] [:fac\r\n;  (let ([d (choose n (= n 1))]\r\n;        [trueV (port :outTrue d)]\r\n;        [falseV (port :outFalse d)])\r\n;    (join\r\n;      trueV\r\n;      (mul (faculty (add falseV -1)) falseV)\r\n;      ))])\r\n\r\n; is the same as\r\n; (defco faculty2 [n] [:fac\r\n;   (join\r\n;     (port :outTrue (choose n (= n 1)))\r\n;     (mul (faculty2 (add (port :outFalse (choose n (= n 1))) -1)) (port :outFalse (choose n (= n 1))))\r\n;     )])\r\n\r\n\r\n; (let [d (choose\r\n;           :input n\r\n;           :control (= :i1 n :i2 1))\r\n;       true (port :outTrue d)\r\n;       false (port :outFalse d)]\r\n;   (dec false -1)\r\n;   (mul false fac)\r\n;   ;(port-out :fac true)\r\n;   )\r\n",
  "nodes": [
    {
      "v": "test_5",
      "value": {
        "id": "test",
        "inputPorts": {
          "s1": "generic",
          "s2": "generic"
        },
        "outputPorts": {
          "sum": "generic",
          "out2": "generic"
        },
        "implementation": {
          "nodes": [
            {
              "meta": "math/add",
              "name": "add_0"
            },
            {
              "meta": "math/add",
              "name": "add_1"
            },
            {
              "meta": "math/const",
              "name": "const(3)_2",
              "params": {
                "value": 3
              }
            },
            {
              "meta": "math/multiply",
              "name": "mul_3"
            },
            {
              "meta": "math/const",
              "name": "const(2)_4",
              "params": {
                "value": 2
              }
            }
          ],
          "edges": [
            {
              "from": "s1",
              "to": "add_0:s1"
            },
            {
              "from": "s2",
              "to": "add_1:s1"
            },
            {
              "from": "const(3)_2:output",
              "to": "add_1:s2"
            },
            {
              "from": "add_1:sum",
              "to": "add_0:s2"
            },
            {
              "from": "add_0:sum",
              "to": "sum"
            },
            {
              "from": "s2",
              "to": "mul_3:m1"
            },
            {
              "from": "const(2)_4:output",
              "to": "mul_3:m2"
            },
            {
              "from": "mul_3:product",
              "to": "out2"
            }
          ]
        },
        "name": "test_5"
      }
    },
    {
      "v": "const(10)_6",
      "value": {
        "meta": "math/const",
        "name": "const(10)_6",
        "params": {
          "value": 10
        }
      }
    },
    {
      "v": "const(20)_7",
      "value": {
        "meta": "math/const",
        "name": "const(20)_7",
        "params": {
          "value": 20
        }
      }
    },
    {
      "v": "add_8",
      "value": {
        "meta": "math/add",
        "name": "add_8"
      }
    },
    {
      "v": "const(3)_9",
      "value": {
        "meta": "math/const",
        "name": "const(3)_9",
        "params": {
          "value": 3
        }
      }
    },
    {
      "v": "add_10",
      "value": {
        "meta": "math/add",
        "name": "add_10"
      }
    },
    {
      "v": "const(10)_11",
      "value": {
        "meta": "math/const",
        "name": "const(10)_11",
        "params": {
          "value": 10
        }
      }
    },
    {
      "v": "mul_12",
      "value": {
        "meta": "math/multiply",
        "name": "mul_12"
      }
    },
    {
      "v": "const(1)_13",
      "value": {
        "meta": "math/const",
        "name": "const(1)_13",
        "params": {
          "value": 1
        }
      }
    },
    {
      "v": "const(2)_14",
      "value": {
        "meta": "math/const",
        "name": "const(2)_14",
        "params": {
          "value": 2
        }
      }
    }
  ],
  "edges": [
    {
      "v": "const(10)_6",
      "w": "test_5",
      "value": {
        "outPort": "output",
        "inPort": "s1"
      }
    },
    {
      "v": "const(20)_7",
      "w": "test_5",
      "value": {
        "outPort": "output",
        "inPort": "s2"
      }
    },
    {
      "v": "const(3)_9",
      "w": "add_8",
      "value": {
        "outPort": "output",
        "inPort": "s1"
      }
    },
    {
      "v": "const(10)_11",
      "w": "add_10",
      "value": {
        "outPort": "output",
        "inPort": "s1"
      }
    },
    {
      "v": "const(1)_13",
      "w": "mul_12",
      "value": {
        "outPort": "output",
        "inPort": "m1"
      }
    },
    {
      "v": "const(2)_14",
      "w": "mul_12",
      "value": {
        "outPort": "output",
        "inPort": "m2"
      }
    },
    {
      "v": "mul_12",
      "w": "add_10",
      "value": {
        "outPort": "product",
        "inPort": "s2"
      }
    },
    {
      "v": "add_10",
      "w": "add_8",
      "value": {
        "outPort": "sum",
        "inPort": "s2"
      }
    }
  ]
}
