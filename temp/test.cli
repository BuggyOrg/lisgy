;(let [input (translator/string_to_array (io/stdin))]
;  (let [m (array/first input)
;        n (array/first (array/rest input))]
;          (io/stdout (translator/number_to_string (math/add m n)))))


;(def add math/add)
;(letr [a (add 1 2)
;      b (add a (add a 3))]
;      (add a b))

; math
(def < math/less)
(def * math/multiply)
(def + math/add)
(def add math/add)
(def ++  math/inc)
(def inc math/inc)

;logic
(def eq logic/equal)
(def eq? logic/equal)
(def == logic/equal)
(def = logic/equal)
(def and logic/and)
(def or logic/or)
(def not logic/not)
(def ! logic/not)
(def mux logic/mux)
(def demux logic/demux)

;new
;(def - sub)(defco sub [s1 s2] (+ s1 (* s2 -1)))
;(defco dec [in] (sub in 1))
;(defco if [check truePath falsePath] (logic/mux truePath falsePath check))
;(def != neq?)(defco neq? [a b] (! (= a b)))


;(defco ack [m n]
;  (if (== m 0)
;    (+ n 1)                           ; m == 0
;    (if (== n 0)
;      (ack (+ m -1) 1)                ; m > 0, n = 0
;      (ack (+ m -1) (ack m (+ n -1))) ; m > 0, n > 0
;      )))

;(defco ackMux (m n)
;  (mux
;    (inc n)                                 ; m = 0
;    (mux
;      (ackMux (+ m -1) 1)                   ; m > 0, n = 0
;      (ackMux (+ m -1) (ackMux m (+ m -1))) ; m > 0, n > 0
;      (== n 0))
;    (== m 0)))


;(if (neq? 2 3) 1 (sub 6 4))

(def a math/add)
(a 2 3)
(def a math/inc)
(a 5)
(add (a 6) 2)
